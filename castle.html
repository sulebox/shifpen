<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Castle — castle.html</title>
  <style>
    html, body { height: 100%; margin: 0; background: #e9f4ea; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 12px; bottom: 12px; padding: 8px 10px; background: rgba(255,255,255,0.9); border-radius: 10px; font: 12px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; color: #222; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    .hud b { font-weight: 700 }
    .log { position: fixed; right: 12px; bottom: 12px; max-width: 44ch; padding: 8px 10px; border-radius: 10px; background: rgba(0,0,0,0.55); color: #fff; font: 12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; box-shadow: 0 6px 18px rgba(0,0,0,0.2); }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">Castle — boy2 は城内、ペンギン5匹が外周を歩きます。</div>
  <div class="log" id="log"></div>

  <script type="module">
    // NOTE: 全て ASCII のみ（環境依存文字は使わない）
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

    // ---------- simple logger (no emoji, ASCII only) ----------
    const logEl = document.getElementById('log');
    function log(m){ if(logEl){ logEl.textContent += (logEl.textContent?'
':'') + m; logEl.scrollTop = logEl.scrollHeight; } }
    function ok(m){ log('[OK] ' + m); }
    function ng(m){ log('[NG] ' + m); }
    log('Start... press L to toggle log');
    addEventListener('keydown', function(e){ if(e.key==='l' || e.key==='L'){ logEl.style.display = (logEl.style.display==='none'?'':'none'); }});

    // ---------- config ----------
    const CONFIG = {
      cameraPos: new THREE.Vector3(0, 14, 22),
      walkOffset: 3.0,
      walkSpeedMin: 1.2,
      walkSpeedMax: 2.0,
      pauseMin: 1.5,
      pauseMax: 3.0,
      groundColor: 0xbfe3bf,
    };

    // ---------- three setup ----------
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe9f4ea);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.copy(CONFIG.cameraPos);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1, 0);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x667766, 0.55));
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(8, 18, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 80;
    sun.shadow.camera.left = -30; sun.shadow.camera.right = 30; sun.shadow.camera.top = 30; sun.shadow.camera.bottom = -30;
    scene.add(sun);

    const loader = new GLTFLoader();
    function shadowify(root){ root.traverse(function(o){ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; }}); }
    function mixerAll(gltf){ if(!gltf.animations || gltf.animations.length===0) return null; const m = new THREE.AnimationMixer(gltf.scene); gltf.animations.forEach(function(c){ m.clipAction(c).play(); }); return m; }

    let castleBBox = null, groundY = 0, castleH = 1;
    const mixers = []; const agents = [];

    // ---------- load castle ----------
    loader.load('castle.glb', function(g){
      const castle = g.scene; shadowify(castle); scene.add(castle);
      const bbox = new THREE.Box3().setFromObject(castle); castleBBox = bbox; groundY = bbox.min.y; castleH = Math.max(0.001, bbox.max.y - bbox.min.y);
      const center = bbox.getCenter(new THREE.Vector3());
      controls.target.copy(center);

      const sizeX = (bbox.max.x - bbox.min.x) + CONFIG.walkOffset*14;
      const sizeZ = (bbox.max.z - bbox.min.z) + CONFIG.walkOffset*14;
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(sizeX, sizeZ), new THREE.MeshStandardMaterial({ color: CONFIG.groundColor }));
      plane.rotation.x = -Math.PI/2; plane.position.set(center.x, groundY - 0.001, center.z); plane.receiveShadow = true; scene.add(plane);

      ok('castle.glb loaded');

      // boy
      loader.load('boy2.glb', function(bg){
        const boy = bg.scene; shadowify(boy);
        const bb = new THREE.Box3().setFromObject(boy); const h = Math.max(0.001, bb.max.y - bb.min.y);
        const s = (castleH*0.18)/h; boy.scale.setScalar(s);
        boy.position.set(center.x, groundY, center.z); scene.add(boy);
        const mix = mixerAll(bg); if(mix) mixers.push(mix);
        ok('boy2.glb loaded');
      }, undefined, function(){ ng('boy2.glb failed to load'); });

      // penguins
      ['pen.glb','pen_b.glb','pen_g.glb','pen_r.glb','pen_y.glb'].forEach(function(fn){
        loader.load(fn, function(pg){
          const p = pg.scene; shadowify(p);
          const bbp = new THREE.Box3().setFromObject(p); const hp = Math.max(0.001, bbp.max.y - bbp.min.y);
          p.scale.setScalar((castleH*0.22)/hp);
          const start = randomPerimeterPoint(castleBBox, CONFIG.walkOffset); p.position.set(start.x, groundY, start.z); scene.add(p);
          const mix = mixerAll(pg); if(mix) mixers.push(mix);
          agents.push(makeAgent(p));
          ok(fn + ' loaded');
        }, undefined, function(){ ng(fn + ' failed to load'); });
      });
    }, undefined, function(){ ng('castle.glb failed to load'); });

    // ---------- agents ----------
    function makeAgent(obj){ return { obj: obj, speed: THREE.MathUtils.randFloat(CONFIG.walkSpeedMin, CONFIG.walkSpeedMax), target: new THREE.Vector3(), state: 'move', waitUntil: 0 }; }
    function pickNext(agent){ if(!castleBBox) return; const next = randomPerimeterPoint(castleBBox, CONFIG.walkOffset); agent.target.copy(next); agent.state = 'move'; }
    function randomPerimeterPoint(bbox, offset){
      const minX = bbox.min.x - offset, maxX = bbox.max.x + offset;
      const minZ = bbox.min.z - offset, maxZ = bbox.max.z + offset;
      const side = Math.floor(Math.random()*4); let x, z;
      if(side===0){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = maxZ + THREE.MathUtils.randFloatSpread(offset*0.35); }
      else if(side===1){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = minZ - THREE.MathUtils.randFloatSpread(offset*0.35); }
      else if(side===2){ x = maxX + THREE.MathUtils.randFloatSpread(offset*0.35); z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
      else { x = minX - THREE.MathUtils.randFloatSpread(offset*0.35); z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
      return new THREE.Vector3(x, groundY, z);
    }

    const clock = new THREE.Clock();
    renderer.setAnimationLoop(function(){
      const dt = clock.getDelta();
      for(var i=0;i<mixers.length;i++){ mixers[i].update(dt); }
      const now = performance.now()/1000;
      for(var j=0;j<agents.length;j++){
        const a = agents[j];
        if(a.state==='idle'){ if(now>=a.waitUntil) pickNext(a); continue; }
        const pos = a.obj.position; const dir = new THREE.Vector3().subVectors(a.target, pos); const d = dir.length();
        if(d<0.05){ a.state='idle'; a.waitUntil = now + THREE.MathUtils.randFloat(CONFIG.pauseMin, CONFIG.pauseMax); continue; }
        dir.normalize(); pos.addScaledVector(dir, a.speed*dt); pos.y = groundY; a.obj.rotation.y = Math.atan2(dir.x, dir.z);
      }
      controls.update(); renderer.render(scene, camera);
    });

    addEventListener('resize', function(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
  </script>
</body>
</html>
