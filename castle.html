<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Castle — castle.html</title>
  <style>
    html, body { height: 100%; margin: 0; background: #e9f4ea; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 12px; bottom: 12px; padding: 8px 10px; background: rgba(255,255,255,0.9); border-radius: 10px; font: 12px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; color: #222; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    .hud b { font-weight: 700 }
    .log { position: fixed; right: 12px; bottom: 12px; max-width: 44ch; padding: 8px 10px; border-radius: 10px; background: rgba(0,0,0,0.55); color: #fff; font: 12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; box-shadow: 0 6px 18px rgba(0,0,0,0.2); }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">Castle — boy2 は城内、ペンギン5匹が外周を歩きます。</div>
  <div class="log" id="log"></div>

  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    // simple logger (ASCII only)
    (function(){
      var logEl = document.getElementById('log');
      function log(m){ if(logEl){ logEl.textContent += (logEl.textContent?'
':'') + m; logEl.scrollTop = logEl.scrollHeight; } }
      function ok(m){ log('[OK] ' + m); }
      function ng(m){ log('[NG] ' + m); }
      log('Start... press L to toggle log');
      addEventListener('keydown', function(e){ if(e.key==='l' || e.key==='L'){ logEl.style.display = (logEl.style.display==='none'?'':'none'); }});

      var CONFIG = {
        cameraPos: new THREE.Vector3(0, 14, 22),
        walkOffset: 3.0,
        walkSpeedMin: 1.2,
        walkSpeedMax: 2.0,
        pauseMin: 1.5,
        pauseMax: 3.0,
        groundColor: 0xbfe3bf
      };

      var app = document.getElementById('app');
      var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.shadowMap.enabled = true;
      app.appendChild(renderer.domElement);

      var scene = new THREE.Scene();
      scene.background = new THREE.Color(0xe9f4ea);

      var camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
      camera.position.copy(CONFIG.cameraPos);

      var controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 1, 0);

      scene.add(new THREE.HemisphereLight(0xffffff, 0x667766, 0.55));
      var sun = new THREE.DirectionalLight(0xffffff, 0.9);
      sun.position.set(8, 18, 6);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048,2048);
      sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 80;
      sun.shadow.camera.left = -30; sun.shadow.camera.right = 30; sun.shadow.camera.top = 30; sun.shadow.camera.bottom = -30;
      scene.add(sun);

      var loader = new THREE.GLTFLoader();
      function shadowify(root){ root.traverse(function(o){ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; }}); }
      function mixerAll(gltf){ if(!gltf.animations || gltf.animations.length===0) return null; var m = new THREE.AnimationMixer(gltf.scene); gltf.animations.forEach(function(c){ m.clipAction(c).play(); }); return m; }

      var castleBBox = null, groundY = 0, castleH = 1;
      var mixers = []; var agents = [];

      loader.load('castle.glb', function(g){
        var castle = g.scene; shadowify(castle); scene.add(castle);
        var bbox = new THREE.Box3().setFromObject(castle); castleBBox = bbox; groundY = bbox.min.y; castleH = Math.max(0.001, bbox.max.y - bbox.min.y);
        var center = bbox.getCenter(new THREE.Vector3());
        controls.target.copy(center);

        var sizeX = (bbox.max.x - bbox.min.x) + CONFIG.walkOffset*14;
        var sizeZ = (bbox.max.z - bbox.min.z) + CONFIG.walkOffset*14;
        var plane = new THREE.Mesh(new THREE.PlaneGeometry(sizeX, sizeZ), new THREE.MeshStandardMaterial({ color: CONFIG.groundColor }));
        plane.rotation.x = -Math.PI/2; plane.position.set(center.x, groundY - 0.001, center.z); plane.receiveShadow = true; scene.add(plane);

        ok('castle.glb loaded');

        loader.load('boy2.glb', function(bg){
          var boy = bg.scene; shadowify(boy);
          var bb = new THREE.Box3().setFromObject(boy); var h = Math.max(0.001, bb.max.y - bb.min.y);
          var s = (castleH*0.18)/h; boy.scale.setScalar(s);
          boy.position.set(center.x, groundY, center.z); scene.add(boy);
          var mix = mixerAll(bg); if(mix) mixers.push(mix);
          ok('boy2.glb loaded');
        }, undefined, function(){ ng('boy2.glb failed to load'); });

        ['pen.glb','pen_b.glb','pen_g.glb','pen_r.glb','pen_y.glb'].forEach(function(fn){
          loader.load(fn, function(pg){
            var p = pg.scene; shadowify(p);
            var bbp = new THREE.Box3().setFromObject(p); var hp = Math.max(0.001, bbp.max.y - bbp.min.y);
            p.scale.setScalar((castleH*0.22)/hp);
            var start = randomPerimeterPoint(castleBBox, CONFIG.walkOffset); p.position.set(start.x, groundY, start.z); scene.add(p);
            var mix = mixerAll(pg); if(mix) mixers.push(mix);
            agents.push(makeAgent(p));
            ok(fn + ' loaded');
          }, undefined, function(){ ng(fn + ' failed to load'); });
        });
      }, undefined, function(){ ng('castle.glb failed to load'); });

      function makeAgent(obj){ return { obj: obj, speed: THREE.MathUtils.randFloat(CONFIG.walkSpeedMin, CONFIG.walkSpeedMax), target: new THREE.Vector3(), state: 'move', waitUntil: 0 }; }
      function pickNext(agent){ if(!castleBBox) return; var next = randomPerimeterPoint(castleBBox, CONFIG.walkOffset); agent.target.copy(next); agent.state = 'move'; }
      function randomPerimeterPoint(bbox, offset){
        var minX = bbox.min.x - offset, maxX = bbox.max.x + offset;
        var minZ = bbox.min.z - offset, maxZ = bbox.max.z + offset;
        var side = Math.floor(Math.random()*4); var x, z;
        if(side===0){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = maxZ + THREE.MathUtils.randFloatSpread(offset*0.35); }
        else if(side===1){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = minZ - THREE.MathUtils.randFloatSpread(offset*0.35); }
        else if(side===2){ x = maxX + THREE.MathUtils.randFloatSpread(offset*0.35); z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
        else { x = minX - THREE.MathUtils.randFloatSpread(offset*0.35); z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
        return new THREE.Vector3(x, groundY, z);
      }

      var clock = new THREE.Clock();
      renderer.setAnimationLoop(function(){
        var dt = clock.getDelta();
        for(var i=0;i<mixers.length;i++){ mixers[i].update(dt); }
        var now = performance.now()/1000;
        for(var j=0;j<agents.length;j++){
          var a = agents[j];
          if(a.state==='idle'){ if(now>=a.waitUntil) pickNext(a); continue; }
          var pos = a.obj.position; var dir = new THREE.Vector3().subVectors(a.target, pos); var d = dir.length();
          if(d<0.05){ a.state='idle'; a.waitUntil = now + THREE.MathUtils.randFloat(CONFIG.pauseMin, CONFIG.pauseMax); continue; }
          dir.normalize(); pos.addScaledVector(dir, a.speed*dt); pos.y = groundY; a.obj.rotation.y = Math.atan2(dir.x, dir.z);
        }
        controls.update(); renderer.render(scene, camera);
      });

      addEventListener('resize', function(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
    })();
  </script>
</body>
</html>
