<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Castle — castle.html</title>
  <style>
    html, body { height: 100%; margin: 0; background: #e9f4ea; }
    #app { position: fixed; inset: 0; }
    .hud {
      position: fixed; left: 12px; bottom: 12px; padding: 8px 10px;
      background: rgba(255,255,255,0.9); border-radius: 10px;
      font: 12px/1.5 -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Hiragino Kaku Gothic ProN\", Meiryo, sans-serif;
      color: #222; box-shadow: 0 6px 18px rgba(0,0,0,0.12);
    }
    .hud b { font-weight: 700 }
    .log {
      position: fixed; right: 12px; bottom: 12px; max-width: 44ch;
      padding: 8px 10px; border-radius: 10px;
      background: rgba(0,0,0,0.55); color: #fff; font: 12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-wrap; box-shadow: 0 6px 18px rgba(0,0,0,0.2);
    }
    .hud b { font-weight: 700 }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id=\"app\"></div>
  <div class=\"hud\">$1</div>
  <div class=\"log\" id=\"log\"></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ===================== CONFIG =====================
    const CONFIG = {
      CAMERA_POS: new THREE.Vector3(0, 14, 22),
      WALK_OFFSET: 3.0,
      WALK_SPEED_MIN: 1.2,
      WALK_SPEED_MAX: 2.2,
      PAUSE_TIME_MIN: 1.5,
      PAUSE_TIME_MAX: 3.0,
      GROUND_COLOR: 0xbfe3bf,
      ENABLE_SHADOWS: true,
    };

    // ===================== LOG PANEL =====================
    const logEl = document.getElementById('log');
    function log(m){ if(logEl){ logEl.textContent += (logEl.textContent?'
':'') + m; logEl.scrollTop = logEl.scrollHeight; } }
    function ok(m){ log(`✅ ${m}`); }
    function ng(m){ log(`❌ ${m}`); }
    log('Loading... (L でログ表示切替)');
    addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='l' && logEl){ logEl.style.display = (logEl.style.display==='none'?'':'none'); }});

    // ===================== THREE BASICS =====================
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = CONFIG.ENABLE_SHADOWS;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe9f4ea);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.position.copy(CONFIG.CAMERA_POS);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 1, 0);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x667766, 0.55);
    scene.add(hemi);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(8, 18, 6);
    dirLight.castShadow = CONFIG.ENABLE_SHADOWS;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 80;
    dirLight.shadow.camera.left = -30;
    dirLight.shadow.camera.right = 30;
    dirLight.shadow.camera.top = 30;
    dirLight.shadow.camera.bottom = -30;
    scene.add(dirLight);

    const loader = new GLTFLoader();

    // Helpers
    function applyShadowFlags(root){
      root.traverse((o)=>{ if(o.isMesh){ o.castShadow = true; o.receiveShadow = true; } });
    }
    function makeMixerIfAny(gltf){
      if(!gltf.animations || gltf.animations.length===0) return null;
      const mixer = new THREE.AnimationMixer(gltf.scene);
      gltf.animations.forEach((clip)=>{ mixer.clipAction(clip).play(); });
      return mixer;
    }

    // Globals
    let castleBBox = null, groundY = 0;
    const mixers = [];
    const agents = [];

    // ===================== LOAD CASTLE =====================
    loader.load('castle.glb', (gltf)=>{
      const castle = gltf.scene; applyShadowFlags(castle); scene.add(castle);
      const bbox = new THREE.Box3().setFromObject(castle); castleBBox = bbox; groundY = bbox.min.y;
      const castleH = Math.max(0.001, bbox.max.y - bbox.min.y);
      const center = bbox.getCenter(new THREE.Vector3());

      controls.target.copy(center);

      // Ground
      const sizeX = (bbox.max.x - bbox.min.x) + CONFIG.WALK_OFFSET * 14;
      const sizeZ = (bbox.max.z - bbox.min.z) + CONFIG.WALK_OFFSET * 14;
      const g = new THREE.PlaneGeometry(sizeX, sizeZ);
      const m = new THREE.MeshStandardMaterial({ color: CONFIG.GROUND_COLOR });
      const ground = new THREE.Mesh(g, m);
      ground.rotation.x = -Math.PI/2; ground.position.set(center.x, groundY - 0.001, center.z); ground.receiveShadow = true; scene.add(ground);

      ok('castle.glb loaded');

      // Boy (城高さの18%)
      loader.load('boy2.glb', (bgltf)=>{
        const boy = bgltf.scene; applyShadowFlags(boy);
        const bb = new THREE.Box3().setFromObject(boy); const h = Math.max(0.001, bb.max.y - bb.min.y);
        const s = (castleH * 0.18) / h; boy.scale.setScalar(s);
        boy.position.set(center.x, groundY, center.z); scene.add(boy);
        const mix = makeMixerIfAny(bgltf); if(mix) mixers.push(mix);
        ok('boy2.glb loaded');
      }, undefined, ()=>{ ng('boy2.glb failed to load'); });

      // Penguins (城高さの22%)
      const files = ['pen.glb','pen_b.glb','pen_g.glb','pen_r.glb','pen_y.glb'];
      files.forEach((f)=>{
        loader.load(f, (pgltf)=>{
          const p = pgltf.scene; applyShadowFlags(p);
          const bbp = new THREE.Box3().setFromObject(p); const hp = Math.max(0.001, bbp.max.y - bbp.min.y);
          p.scale.setScalar((castleH*0.22)/hp);
          const start = randomPointOnPerimeter(castleBBox, CONFIG.WALK_OFFSET);
          p.position.set(start.x, groundY, start.z); scene.add(p);
          const mix = makeMixerIfAny(pgltf); if(mix) mixers.push(mix);
          agents.push(createAgent(p));
          ok(f + ' loaded');
        }, undefined, ()=>{ ng(f + ' failed to load'); });
      });
    }, undefined, ()=>{ ng('castle.glb failed to load'); });

    // ===================== AGENTS =====================
    function createAgent(obj){
      return {
        obj,
        speed: THREE.MathUtils.randFloat(CONFIG.WALK_SPEED_MIN, CONFIG.WALK_SPEED_MAX),
        target: new THREE.Vector3(),
        state: 'move',
        waitUntil: 0,
      };
    }
    function pickNextTarget(agent){
      if(!castleBBox) return; const next = randomPointOnPerimeter(castleBBox, CONFIG.WALK_OFFSET);
      agent.target.copy(next); agent.state = 'move';
    }
    function randomPointOnPerimeter(bbox, offset){
      const minX = bbox.min.x - offset, maxX = bbox.max.x + offset;
      const minZ = bbox.min.z - offset, maxZ = bbox.max.z + offset;
      const side = Math.floor(Math.random()*4); let x, z;
      if(side===0){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = maxZ + THREE.MathUtils.randFloatSpread(offset*0.35); }
      else if(side===1){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = minZ - THREE.MathUtils.randFloatSpread(offset*0.35); }
      else if(side===2){ x = maxX + THREE.MathUtils.randFloatSpread(offset*0.35); z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
      else { x = minX - THREE.MathUtils.randFloatSpread(offset*0.35); z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
      return new THREE.Vector3(x, groundY, z);
    }

    // ===================== LOOP =====================
    const clock = new THREE.Clock();
    function update(dt){
      mixers.forEach(m=>m.update(dt));
      const now = performance.now()/1000;
      for(const a of agents){
        if(a.state==='idle'){ if(now>=a.waitUntil) pickNextTarget(a); continue; }
        const pos = a.obj.position; const dir = new THREE.Vector3().subVectors(a.target, pos); const d = dir.length();
        if(d < 0.05){ a.state='idle'; a.waitUntil = now + THREE.MathUtils.randFloat(CONFIG.PAUSE_TIME_MIN, CONFIG.PAUSE_TIME_MAX); continue; }
        dir.normalize(); pos.addScaledVector(dir, a.speed*dt); pos.y = groundY; a.obj.rotation.y = Math.atan2(dir.x, dir.z);
      }
    }
    renderer.setAnimationLoop(()=>{ const dt = clock.getDelta(); update(dt); controls.update(); renderer.render(scene, camera); });

    // ===================== RESIZE =====================
    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
  </script>
</body>
</html>
