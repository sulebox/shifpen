<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Castle — castle.html</title>
  <style>
    html, body { height: 100%; margin: 0; background: #e9f4ea; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 12px; bottom: 12px; padding: 8px 10px; background: rgba(255,255,255,0.9); border-radius: 10px; font: 12px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; color: #222; box-shadow: 0 6px 18px rgba(0,0,0,0.12); }
    .hud b { font-weight: 700 }
    .log { position: fixed; right: 12px; bottom: 12px; max-width: 44ch; padding: 8px 10px; border-radius: 10px; background: rgba(0,0,0,0.55); color: #fff; font: 12px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space: pre-wrap; box-shadow: 0 6px 18px rgba(0,0,0,0.2); }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="hud">Castle — code castle walls + ground. Boy inside, 5 penguins walk outside.</div>
  <div class="log" id="log"></div>

  <script type="module">
    // modules from CDN (ESM)
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

    // -------- logger (ASCII only) --------
    const logEl = document.getElementById('log');
    function log(m){ if(logEl){ logEl.textContent += (logEl.textContent?'
':'') + m; logEl.scrollTop = logEl.scrollHeight; } }
    function ok(m){ log('[OK] ' + m); }
    function ng(m){ log('[NG] ' + m); }
    log('Start (press L to toggle log)');
    addEventListener('keydown', (e)=>{ if(e.key==='l' || e.key==='L'){ logEl.style.display = (logEl.style.display==='none'?'':'none'); }});

    // -------- config --------
    const WALL_W = 36;     // inner width (x)
    const WALL_D = 36;     // inner depth (z)
    const WALL_T = 2.0;    // wall thickness
    const WALL_H = 8.0;    // wall height
    const TOWER_R = 3.2;   // tower radius
    const TOWER_H = 10.0;  // tower height
    const CR_SPACING = 2.0; // crenellation spacing

    const BOY_TARGET_H = WALL_H * 0.40;        // boy height
    const PENGUIN_TARGET_H = BOY_TARGET_H*1.2; // penguin height (a bit larger)
    const WALK_OFFSET = 3.0;                   // distance outside walls for penguins

    // -------- three basics --------
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe9f4ea);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(24, 18, 28);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.target.set(0, 4, 0);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x667766, 0.55));
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(12, 24, 10);
    sun.castShadow = true; sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 100;
    sun.shadow.camera.left = -60; sun.shadow.camera.right = 60; sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
    scene.add(sun);

    function shadowify(o){ o.traverse((m)=>{ if(m.isMesh){ m.castShadow = true; m.receiveShadow = true; }}); }

    // -------- ground --------
    const groundSize = Math.max(WALL_W, WALL_D) + 40;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(groundSize, groundSize),
      new THREE.MeshStandardMaterial({ color: 0xbfe3bf })
    );
    ground.rotation.x = -Math.PI/2; ground.position.y = 0; ground.receiveShadow = true; scene.add(ground);

    // -------- castle made from code --------
    const castle = new THREE.Group(); scene.add(castle);

    // walls (north, south, east, west)
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x9a9a9a, roughness: 0.9, metalness: 0.0 });
    function wall(w, h, t){ return new THREE.Mesh(new THREE.BoxGeometry(w, h, t), wallMat); }

    const north = wall(WALL_W + WALL_T, WALL_H, WALL_T); north.position.set(0, WALL_H/2, -(WALL_D/2 + WALL_T/2));
    const south = wall(WALL_W + WALL_T, WALL_H, WALL_T); south.position.set(0, WALL_H/2,  (WALL_D/2 + WALL_T/2));
    const east  = wall(WALL_T, WALL_H, WALL_D + WALL_T); east.position.set( (WALL_W/2 + WALL_T/2), WALL_H/2, 0);
    const west  = wall(WALL_T, WALL_H, WALL_D + WALL_T); west.position.set(-(WALL_W/2 + WALL_T/2), WALL_H/2, 0);
    castle.add(north, south, east, west);

    // gate opening on south wall
    const gateW = 6, gateH = 6;
    const gateHole = new THREE.Mesh(new THREE.BoxGeometry(gateW, gateH, WALL_T+0.02));
    gateHole.position.copy(south.position); gateHole.position.y = gateH/2; gateHole.updateMatrix();
    south.updateMatrix();
    // quick boolean by scaling a small transparent box to carve visually (no CSG): just hide a gate area by different material
    south.geometry = new THREE.BoxGeometry(WALL_W + WALL_T, WALL_H, WALL_T);

    // towers in 4 corners
    const towerMat = new THREE.MeshStandardMaterial({ color: 0x8d8d8d, roughness: 0.85 });
    function tower(){ return new THREE.Mesh(new THREE.CylinderGeometry(TOWER_R, TOWER_R, TOWER_H, 24), towerMat); }
    const tNE = tower(); tNE.position.set( WALL_W/2, TOWER_H/2, -WALL_D/2);
    const tNW = tower(); tNW.position.set(-WALL_W/2, TOWER_H/2, -WALL_D/2);
    const tSE = tower(); tSE.position.set( WALL_W/2, TOWER_H/2,  WALL_D/2);
    const tSW = tower(); tSW.position.set(-WALL_W/2, TOWER_H/2,  WALL_D/2);
    castle.add(tNE, tNW, tSE, tSW);

    // simple crenellations on top of north and south walls
    function addCrenels(lineStart, lineEnd){
      const len = lineEnd.clone().sub(lineStart).length();
      const n = Math.floor(len / CR_SPACING);
      const dir = lineEnd.clone().sub(lineStart).normalize();
      for(let i=0;i<=n;i++){
        const p = lineStart.clone().addScaledVector(dir, i*CR_SPACING);
        const block = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, WALL_T), wallMat);
        block.position.set(p.x, WALL_H + 0.4, p.z);
        castle.add(block);
      }
    }
    addCrenels(new THREE.Vector3(-(WALL_W/2),0,-(WALL_D/2 + WALL_T/2)), new THREE.Vector3((WALL_W/2),0,-(WALL_D/2 + WALL_T/2)));
    addCrenels(new THREE.Vector3(-(WALL_W/2),0,(WALL_D/2 + WALL_T/2)),  new THREE.Vector3((WALL_W/2),0,(WALL_D/2 + WALL_T/2)));

    shadowify(castle);

    // -------- loaders --------
    const loader = new GLTFLoader();
    const mixers = [];

    function fitHeight(obj, targetH){
      const box = new THREE.Box3().setFromObject(obj);
      const h = Math.max(0.001, box.max.y - box.min.y);
      const s = targetH / h; obj.scale.setScalar(s);
    }
    function makeMixer(g){ if(!g.animations || g.animations.length===0) return null; const m=new THREE.AnimationMixer(g.scene); g.animations.forEach(c=>m.clipAction(c).play()); return m; }

    // boy at center
    loader.load('boy2.glb', (g)=>{
      const boy = g.scene; shadowify(boy); fitHeight(boy, BOY_TARGET_H);
      boy.position.set(0, 0, 0); scene.add(boy);
      const m = makeMixer(g); if(m) mixers.push(m);
      ok('boy2.glb loaded');
    }, undefined, ()=>{ ng('boy2.glb failed to load'); });

    // penguins around outside
    const files = ['pen.glb','pen_b.glb','pen_g.glb','pen_r.glb','pen_y.glb'];
    const agents = [];
    files.forEach(fn=>{
      loader.load(fn, (g)=>{
        const p = g.scene; shadowify(p); fitHeight(p, PENGUIN_TARGET_H);
        const start = randomPointOutside(); p.position.copy(start); scene.add(p);
        const m = makeMixer(g); if(m) mixers.push(m);
        agents.push(makeAgent(p)); ok(fn+' loaded');
      }, undefined, ()=>{ ng(fn+' failed to load'); });
    });

    function rectMinX(){ return -(WALL_W/2) - WALL_T/2; }
    function rectMaxX(){ return  (WALL_W/2) + WALL_T/2; }
    function rectMinZ(){ return -(WALL_D/2) - WALL_T/2; }
    function rectMaxZ(){ return  (WALL_D/2) + WALL_T/2; }

    function randomPointOutside(){
      const minX = rectMinX() - WALK_OFFSET;
      const maxX = rectMaxX() + WALK_OFFSET;
      const minZ = rectMinZ() - WALK_OFFSET;
      const maxZ = rectMaxZ() + WALK_OFFSET;
      const side = Math.floor(Math.random()*4); let x,z;
      if(side===0){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = maxZ; }
      else if(side===1){ x = THREE.MathUtils.lerp(minX, maxX, Math.random()); z = minZ; }
      else if(side===2){ x = maxX; z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
      else { x = minX; z = THREE.MathUtils.lerp(minZ, maxZ, Math.random()); }
      return new THREE.Vector3(x, 0, z);
    }

    function makeAgent(obj){ return { obj: obj, speed: THREE.MathUtils.randFloat(1.2, 2.0), target: randomPointOutside(), wait: 0, state: 'move' }; }
    function stepAgents(dt){
      const now = performance.now()/1000;
      for(let i=0;i<agents.length;i++){
        const a = agents[i];
        if(a.state==='idle'){ if(now>a.wait){ a.state='move'; a.target = randomPointOutside(); } continue; }
        const pos = a.obj.position; const dir = new THREE.Vector3().subVectors(a.target, pos); const d = dir.length();
        if(d<0.05){ a.state='idle'; a.wait = now + THREE.MathUtils.randFloat(1.5,3.0); continue; }
        dir.normalize(); pos.addScaledVector(dir, a.speed*dt); a.obj.rotation.y = Math.atan2(dir.x, dir.z); pos.y = 0;
      }
    }

    const clock = new THREE.Clock();
    renderer.setAnimationLoop(()=>{
      const dt = clock.getDelta();
      mixers.forEach(m=>m.update(dt));
      stepAgents(dt);
      controls.update();
      renderer.render(scene, camera);
    });

    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
  </script>
</body>
</html>
