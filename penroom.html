<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Penguin Room — penroom.html (v45)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #f6e6c9; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    #app { position: fixed; inset: 0; }
    .hud { position: fixed; left: 12px; bottom: 12px; padding: 8px 10px; background: rgba(255,255,255,0.85); border-radius: 10px; font: 12px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; color: #333; box-shadow: 0 4px 14px rgba(0,0,0,.08); }
    .status { position: fixed; left: 12px; top: 12px; padding: 6px 8px; background: rgba(0,0,0,.6); color: #fff; border-radius: 8px; font: 12px/1.4 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; white-space: pre-wrap; max-width: 60ch; }
    .picker { position: fixed; right: 12px; top: 12px; }
    .picker button { font: 12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; padding: 6px 10px; border-radius: 10px; border: 1px solid rgba(0,0,0,.15); background: #fff; }
    .drop { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; border: 2px dashed rgba(0,0,0,.15); border-radius: 16px; pointer-events: none; opacity: 0; transition: .2s; }
    .drop.on { opacity: 1; }
    a { color: inherit; }
    .bubble { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -100%); padding: 6px 10px; background: rgba(255,255,255,.95); border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,.12); font: 12px/1.5 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif; pointer-events: none; transition: opacity .2s; }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="status" id="status">初期化中…</div>
  <div class="hud">クリック/タップで次の行動にスキップ</div>
  <div class="drop" id="drop"><div style="background:#fff;padding:16px 18px;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,.12)">ここにGLBをドロップ</div></div>
  <div class="bubble" id="bubble" style="display:none"></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <script type="module">
    // ---- Imports ----
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';

    // ---- Helpers ----
    const $ = (id) => document.getElementById(id);
    const setStatus = (m) => { const st=$('status'); if(st){ st.textContent = m; } console.log(m); };

    // ---- Renderer / Scene ----
    const app = $('app');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xF8EBD5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    app.appendChild(renderer.domElement);

    // ---- Camera ----
    let aspect = window.innerWidth / window.innerHeight;
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 100);
    camera.position.set(14, 16, 14);
    camera.lookAt(0, 0, 0);
    function fitCameraToRoom(){
      const corners = [
        new THREE.Vector3(-9,0,-7), new THREE.Vector3(9,0,-7), new THREE.Vector3(-9,0,7), new THREE.Vector3(9,0,7),
        new THREE.Vector3(-9,5,-7), new THREE.Vector3(9,5,-7), new THREE.Vector3(-9,5,7), new THREE.Vector3(9,5,7)
      ];
      const inv = new THREE.Matrix4().copy(camera.matrixWorldInverse);
      let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
      for(const v of corners){ const vc = v.clone().applyMatrix4(inv); minX=Math.min(minX,vc.x); maxX=Math.max(maxX,vc.x); minY=Math.min(minY,vc.y); maxY=Math.max(maxY,vc.y); }
      const pad = 0.6;
      const width = (maxX-minX) + pad*2;
      const height = (maxY-minY) + pad*2;
      aspect = window.innerWidth / window.innerHeight;
      const frustumSize = Math.max(height, width / aspect);
      camera.left = -frustumSize * aspect / 2;
      camera.right = frustumSize * aspect / 2;
      camera.top = frustumSize / 2;
      camera.bottom = -frustumSize / 2;
      camera.updateProjectionMatrix();
    }
    function setDesktopOrtho(){
      const frustumSize = 22;
      aspect = window.innerWidth / window.innerHeight;
      camera.left = -frustumSize * aspect / 2;
      camera.right = frustumSize * aspect / 2;
      camera.top = frustumSize / 2;
      camera.bottom = -frustumSize / 2;
      camera.updateProjectionMatrix();
    }
    function isSmallScreen(){ return Math.min(window.innerWidth, window.innerHeight) < 800; }
    function updateCameraMode(){
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (isSmallScreen()) fitCameraToRoom(); else setDesktopOrtho();
    }
    window.addEventListener('resize', updateCameraMode);

    // ---- Lights ----
    scene.add(new THREE.HemisphereLight(0xffffff, 0xf2d8a8, 0.85));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 2);
    scene.add(dir);

    // ---- Room ----
    const room = new THREE.Group();
    scene.add(room);
    const floorGeo = new THREE.PlaneGeometry(18, 14);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0xF4D9A0, roughness: 0.95 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    room.add(floor);

    const wallH = 5, wallT = 0.3;
    const wallMat = new THREE.MeshStandardMaterial({ color: 0xF7CD8F });
    const mkWall = (w,h,t) => new THREE.Mesh(new THREE.BoxGeometry(w,h,t), wallMat);

    // 後ろの壁（元に戻す）
    const back = mkWall(18, wallH, wallT); back.position.set(0, wallH/2, -7); room.add(back);

    // 左壁：上側（ドアより前のパート）を削除、下側だけ残す
    const DOOR_X = -9, DOOR_Z_MIN = 3.5, DOOR_Z_MAX = 6.5;
    // const leftA = mkWall(wallT, wallH, (DOOR_Z_MIN - (-7))); leftA.position.set(-9, wallH/2, (-7 + DOOR_Z_MIN)/2); room.add(leftA); // ← 削除指示
    // const leftB = mkWall(wallT, wallH, (7 - DOOR_Z_MAX));   leftB.position.set(-9, wallH/2, (7 + DOOR_Z_MAX)/2);   room.add(leftB); // ← 削除指示

    // 右壁＋窓はそのまま
    const rightGroup = new THREE.Group(); room.add(rightGroup); const rightX = 9;
    const beamMat = new THREE.MeshStandardMaterial({ color: 0xE9A86B });
    const beamT = wallT;
    const frameTop = new THREE.Mesh(new THREE.BoxGeometry(beamT, 0.4, 13), beamMat); frameTop.position.set(rightX, 4.2, 0); rightGroup.add(frameTop);
    const frameBottom = new THREE.Mesh(new THREE.BoxGeometry(beamT, 0.4, 13), beamMat); frameBottom.position.set(rightX, 1.6, 0); rightGroup.add(frameBottom);
    const frameLeft = new THREE.Mesh(new THREE.BoxGeometry(beamT, 2.2, 0.3), beamMat); frameLeft.position.set(rightX, 2.9, -6.5); rightGroup.add(frameLeft);
    const frameRight = new THREE.Mesh(new THREE.BoxGeometry(beamT, 2.2, 0.3), beamMat); frameRight.position.set(rightX, 2.9, 6.5); rightGroup.add(frameRight);
    const rightTopWall = new THREE.Mesh(new THREE.BoxGeometry(beamT, 0.5, 14), wallMat); rightTopWall.position.set(rightX, 4.75, 0); room.add(rightTopWall);
    const rightBottomWall = new THREE.Mesh(new THREE.BoxGeometry(beamT, 0.5, 14), wallMat); rightBottomWall.position.set(rightX, 1.0, 0); room.add(rightBottomWall);

    updateCameraMode();
    const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xA7D0FF, transmission: 0.9, thickness: 0.02, roughness: 0.1, transparent: true, opacity: 0.6 });
    const glass = new THREE.Mesh(new THREE.BoxGeometry(0.02, 2.2, 13), glassMat); glass.position.set(rightX - 0.02, 2.9, 0); rightGroup.add(glass);

    // ---- Garden (元の広さに戻す) ----
    const garden = new THREE.Group(); scene.add(garden);
    const lawnMat = new THREE.MeshStandardMaterial({ color: 0xCDE7B0, roughness: 0.95 });
    const frontLawn = new THREE.Mesh(new THREE.PlaneGeometry(18, 8), lawnMat); frontLawn.rotation.x = -Math.PI/2; frontLawn.position.set(0, 0, 11); garden.add(frontLawn);
    const leftLawn  = new THREE.Mesh(new THREE.PlaneGeometry(8, 14), lawnMat); leftLawn.rotation.x = -Math.PI/2; leftLawn.position.set(-13, 0, 0); garden.add(leftLawn);

    // tree
    const tree = new THREE.Group(); garden.add(tree); tree.position.set(-12, 0, 3.5);
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.35, 2.2, 12), new THREE.MeshStandardMaterial({ color: 0x8D6E63 })); trunk.position.y = 1.1; tree.add(trunk);
    const crown1 = new THREE.Mesh(new THREE.SphereGeometry(1.2, 16, 12), new THREE.MeshStandardMaterial({ color: 0x7CB342 })); crown1.position.y = 2.2; tree.add(crown1);
    const crown2 = new THREE.Mesh(new THREE.SphereGeometry(0.9, 16, 12), new THREE.MeshStandardMaterial({ color: 0x8BC34A })); crown2.position.set(0.9, 2.9, 0.2); tree.add(crown2);

    // pond
    const pond = new THREE.Group(); garden.add(pond);
    const rim = new THREE.Mesh(new THREE.CylinderGeometry(2.3, 2.3, 0.12, 48, 1, true), new THREE.MeshStandardMaterial({ color: 0xA1887F })); rim.position.set(-2.0, 0.06, 10.0); pond.add(rim);
    const water = new THREE.Mesh(new THREE.CylinderGeometry(2.1, 2.1, 0.05, 48), new THREE.MeshStandardMaterial({ color: 0xB3E5FF, roughness: 0.25, metalness: 0 })); water.position.set(-2.0, 0.081, 10.0); water.renderOrder = 2; pond.add(water);

    // --- pond helpers ---
    const POND_POS = water.position.clone();
    const droplets = [];
    const dropletGeo = new THREE.SphereGeometry(0.06, 10, 8);
    const dropletBaseMat = new THREE.MeshStandardMaterial({ color: 0xB3E5FF, metalness:0, roughness:0.2, transparent:true, opacity:0.9 });
    function spawnSplash(pos, count=6){
      for(let i=0;i<count;i++){
        const m = new THREE.Mesh(dropletGeo, dropletBaseMat.clone());
        m.position.copy(pos).add(new THREE.Vector3((Math.random()-0.5)*0.4, 0.1, (Math.random()-0.5)*0.4));
        m.userData = { vel: new THREE.Vector3((Math.random()-0.5)*1.2, 1.5+Math.random()*0.8, (Math.random()-0.5)*1.2), life: 0.7 };
        scene.add(m);
        droplets.push(m);
      }
    }

    // ---- Cat ----
    const cat = new THREE.Group(); garden.add(cat); cat.position.set(-11.2, 0, 2.5);
    const catMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
    const catBody = new THREE.Mesh(new THREE.SphereGeometry(0.45, 18, 14), catMat); catBody.scale.set(1.4, 0.9, 1.8); catBody.position.y = 0.45; cat.add(catBody);
    const catHead = new THREE.Mesh(new THREE.SphereGeometry(0.28, 18, 14), catMat); catHead.position.set(0, 0.9, 0.2); cat.add(catHead);
    const earMat = new THREE.MeshStandardMaterial({ color: 0xFFE0E0 });
    const earL = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.18, 12), earMat); earL.position.set(-0.12, 1.05, 0.18); cat.add(earL);
    const earR = earL.clone(); earR.position.x = 0.12; cat.add(earR);
    const eyeMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.03, 12, 8), eyeMat); eyeL.position.set(-0.07, 0.93, 0.35); cat.add(eyeL);
    const eyeR = eyeL.clone(); eyeR.position.x = 0.07; cat.add(eyeR);
    const nose = new THREE.Mesh(new THREE.SphereGeometry(0.025, 10, 8), new THREE.MeshStandardMaterial({ color: 0xF8BBD0 })); nose.position.set(0, 0.9, 0.4); cat.add(nose);
    const legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.22, 10);
    for (let i=0;i<4;i++){ const leg = new THREE.Mesh(legGeo, catMat); leg.position.set(i<2?-0.15:0.15, 0.11, i%2?0.1:-0.25); cat.add(leg); }
    const catTail = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5, 10), catMat); catTail.position.set(0, 0.6, -0.45); catTail.rotation.x = Math.PI/3; cat.add(catTail);
    garden.userData.catHead = catHead; garden.userData.catTail = catTail;

    // ---- Toys & props ----
    const toys = new THREE.Group(); scene.add(toys);
    const RING_X = 4.0, RING_Z = -3.0;
    const addBlock = (x,z,color) => { const m = new THREE.Mesh(new THREE.BoxGeometry(0.9,0.9,0.9), new THREE.MeshStandardMaterial({ color })); m.position.set(x,0.45,z); toys.add(m); return m; };
    const blocks = [];
    blocks.push(addBlock(-4,-2,0xf9a825));
    blocks.push(addBlock(-5,-1,0x4fc3f7));
    blocks.push(addBlock(-3,-1,0x81c784));
    const BLOCKS_POS = new THREE.Vector3(
      (blocks[0].position.x + blocks[1].position.x + blocks[2].position.x)/3, 0,
      (blocks[0].position.z + blocks[1].position.z + blocks[2].position.z)/3
    );

    const ring = (radius, y, color) => { const g=new THREE.TorusGeometry(radius,0.15,12,32); const m=new THREE.MeshStandardMaterial({ color }); const t=new THREE.Mesh(g,m); t.rotation.x=Math.PI/2; t.position.set(RING_X, y, RING_Z); toys.add(t); return t; };
    ring(0.8, 0.35, 0xff8a65); ring(0.65, 0.55, 0x4db6ac); ring(0.5, 0.75, 0x9575cd);
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,1.2,16), new THREE.MeshStandardMaterial({ color: 0xd7ccc8 })); pole.position.set(RING_X,0.6,RING_Z); toys.add(pole);
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.7,0.2,20), new THREE.MeshStandardMaterial({ color: 0xef9a9a })); base.position.set(RING_X,0.1,RING_Z); toys.add(base);

    const dish = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 0.1, 24), new THREE.MeshStandardMaterial({ color: 0x90caf9 })); dish.position.set(2, 0.05, 2); scene.add(dish);

    // ---- Bed（元の位置・向きのまま） ----
    const bed = new THREE.Group(); scene.add(bed);
    const bedX = -4.8, bedZ = 5.2;
    const woodMat = new THREE.MeshStandardMaterial({ color: 0xC18E66 });
    const fabricMat = new THREE.MeshStandardMaterial({ color: 0xEDE7F6 });
    const blanketMat = new THREE.MeshStandardMaterial({ color: 0x9bd0ff });
    const bedBase = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.25, 1.8), woodMat); bedBase.position.set(bedX, 0.125, bedZ); bed.add(bedBase);
    const headBoard = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.6, 0.12), woodMat); headBoard.position.set(bedX, 0.55, bedZ - 0.95); bed.add(headBoard);
    const mattress = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.22, 1.6), fabricMat); mattress.position.set(bedX, 0.36, bedZ); bed.add(mattress);
    const blanket = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.12, 1.2), blanketMat); blanket.position.set(bedX + 0.2, 0.48, bedZ + 0.05); bed.add(blanket);
    const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.15, 0.45), new THREE.MeshStandardMaterial({ color: 0xffffff })); pillow.position.set(bedX - 1.3, 0.5, bedZ + 0.0); pillow.rotation.y = Math.PI / 2; bed.add(pillow);
    const BED_SLEEP = { x: bedX - 0.9, z: bedZ - 0.45, y: 0.55 };

    // ---- Resource queues ----
    const RES = {
      play:  { holder: null, queue: [], pos: new THREE.Vector3(RING_X, 0, RING_Z), waitDir: new THREE.Vector3(-1,0,0) },
      playBlocks: { holder: null, queue: [], pos: BLOCKS_POS.clone(), waitDir: new THREE.Vector3(-1,0,0) },
      eat:   { holder: null, queue: [], pos: dish.position.clone(), waitDir: new THREE.Vector3(-1,0,0) },
      sleep: { holder: null, queue: [], pos: new THREE.Vector3(BED_SLEEP.x, 0, BED_SLEEP.z), waitDir: new THREE.Vector3(1,0,0) },
      pond:  { holder: null, queue: [], pos: POND_POS.clone(), waitDir: new THREE.Vector3(1,0,0) }
    };
    function requestResource(p, name){ const r = RES[name]; if(!r.holder){ r.holder = p; return true; } if(!r.queue.includes(p)) r.queue.push(p); return false; }
    function releaseResource(name){ const r = RES[name]; if(r.holder) r.holder = null; const next = r.queue.shift(); if(next) setState(next, name); }
    function queueWaitPos(name, p){ const r = RES[name]; const idx = r.queue.indexOf(p); const spacing = 0.9; const off = r.waitDir.clone().multiplyScalar((idx+1)*spacing); return r.pos.clone().add(off); }
    function dequeueAll(p){ ['play','playBlocks','eat','sleep','pond'].forEach(n=>{ const r=RES[n]; const i=r.queue.indexOf(p); if(i>=0) r.queue.splice(i,1); if(r.holder===p) r.holder=null; }); }

    // ---- Mobile toy ----
    const mobile = new THREE.Group(); scene.add(mobile); mobile.position.set(-5, 3.8, -4.5);
    const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,1.2,12), new THREE.MeshStandardMaterial({ color: 0xd7ccc8 })); rod.rotation.z = Math.PI/2; mobile.add(rod);
    const stringMat = new THREE.MeshStandardMaterial({ color: 0xd7ccc8 });
    const makeFish = () => { const fish = new THREE.Group(); const body = new THREE.Mesh(new THREE.SphereGeometry(0.18,16,12), new THREE.MeshStandardMaterial({ color: 0x64b5f6 })); body.scale.set(1.5,1,1); fish.add(body); const tail = new THREE.Mesh(new THREE.ConeGeometry(0.18,0.3,16), new THREE.MeshStandardMaterial({ color: 0xffcc80 })); tail.rotation.z = Math.PI/2; tail.position.set(-0.35,0,0); fish.add(tail); const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04,10,8), new THREE.MeshStandardMaterial({ color: 0x222 })); eye.position.set(0.2,0.08,0.12); fish.add(eye); return fish; };
    const hangFish = (oz) => { const s = new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,1.0,8), stringMat); s.position.set(0,-0.5,oz); mobile.add(s); const f = makeFish(); f.position.set(0,-1.1,oz); mobile.add(f); return f; };
    const mf1 = hangFish(-0.35), mf2 = hangFish(0), mf3 = hangFish(0.35);

    // ---- GLTF loader (shared) ----
    let penguin = null; const penguins = [];
    const gltfLoader = new GLTFLoader();
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/');
    gltfLoader.setDRACOLoader(draco);

    const bounds = { xMin: -16, xMax: 7.5, zMin: -5.5, zMax: 13 };
    const targetHeight = 2.2;
    const HEADING_OFFSET = Math.PI;

    // ---- Comments / bubbles ----
    const commentMap = {
      wander: 'おさんぽしよっと',
      lounge: 'ちょとつかれた',
      play:   'あそぼっと',
      playBlocks: 'あそぼっと',
      eat:    'おなかすいた',
      window: 'そとなにあるかな',
      sleep:  'もうねよっと',
      wake:   '',
      sit:    'ちょときゅうけい',
      pond:   'ちょとあつい'
    };
    function ensureBubble(p){ if (!p.userData.bubbleEl) { const el = document.createElement('div'); el.className='bubble'; document.body.appendChild(el); p.userData.bubbleEl = el; } return p.userData.bubbleEl; }
    function setBubble(p, state){ const el = ensureBubble(p); el.textContent = commentMap[state] || ''; el.style.opacity = el.textContent ? 1 : 0; }
    function updateBubblePositionFor(p){ const el = p.userData.bubbleEl; if (!el) return; const world = p.position.clone().add(new THREE.Vector3(0,2.6,0)); const q = world.project(camera); el.style.left = (q.x*0.5+0.5)*window.innerWidth+'px'; el.style.top = (-q.y*0.5+0.5)*window.innerHeight+'px'; }

    // ---- Penguin load helpers ----
    function fitAndFloor(model) {
      const tmp = new THREE.Group(); tmp.add(model); scene.add(tmp);
      tmp.updateWorldMatrix(true,true);
      const box = new THREE.Box3().setFromObject(tmp);
      const size = new THREE.Vector3(); box.getSize(size);
      const s = (size.y>0? targetHeight/size.y : 1);
      model.scale.setScalar(s);
      tmp.updateWorldMatrix(true,true);
      const box2 = new THREE.Box3().setFromObject(tmp);
      model.position.y += -box2.min.y;
      scene.remove(tmp);
      return model;
    }

    async function loadPenguin(url) {
      setStatus('loading ' + url + ' ...');
      return new Promise((resolve, reject) => {
        gltfLoader.load(url, (gltf) => {
          const st=$('status'); if(st){ st.textContent=''; st.style.display='none'; }
          const root = new THREE.Group();
          const model = gltf.scene;
          model.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
          fitAndFloor(model);
          root.add(model);
          let mixer = null;
          if (gltf.animations && gltf.animations.length) {
            mixer = new THREE.AnimationMixer(model);
            const action = mixer.clipAction(gltf.animations[0]);
            action.play();
          }
          root.userData = { speed: 0, state: 'idle', target: new THREE.Vector3(), timer: 0, mixer, model, goingToBed: false };
          resolve(root);
        }, undefined, (err) => { console.error('GLB load error:', err); setStatus('GLB load error: ' + (err?.message || err)); reject(err); });
      });
    }

    function fallbackPenguin() {
      const g = new THREE.Group();
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.9, 24, 18), new THREE.MeshStandardMaterial({ color: 0x4b4f57 })); body.scale.set(1, 1.4, 1); body.position.y = 1.2; g.add(body);
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.45, 24, 18), new THREE.MeshStandardMaterial({ color: 0x1f2124 })); head.position.set(0, 2.05, 0.05); g.add(head);
      g.userData = { speed: 0, state: 'idle', target: new THREE.Vector3(), timer: 0 };
      return g;
    }

    // ---- Behavior helpers ----
    function randomPointNear(x0, z0, r=5) {
      const x = THREE.MathUtils.clamp(x0 + (Math.random()*2-1)*r, bounds.xMin, bounds.xMax);
      const z = THREE.MathUtils.clamp(z0 + (Math.random()*2-1)*r, bounds.zMin, bounds.zMax);
      return new THREE.Vector3(x,0,z);
    }
    function doorWaypoint(from, to){
      if ((from.x > DOOR_X && to.x < DOOR_X) || (from.x < DOOR_X && to.x > DOOR_X)) {
        return new THREE.Vector3(DOOR_X, 0, (DOOR_Z_MIN + DOOR_Z_MAX) / 2);
      }
      return null;
    }
    function setRoute(p, dest){
      const d = doorWaypoint(p.position, dest);
      p.userData.way = [];
      if (d) { p.userData.way = [dest.clone()]; p.userData.target.copy(d); }
      else { p.userData.target.copy(dest); }
    }

    function chooseNextAction(p){
      if (!p) return; const r = Math.random();
      if (r < 0.27) setState(p,'wander');
      else if (r < 0.42) setState(p,'lounge');
      else if (r < 0.49) setState(p,'play');
      else if (r < 0.57) setState(p,'playBlocks');
      else if (r < 0.72) setState(p,'eat');
      else if (r < 0.82) setState(p,'pond');
      else if (r < 0.92) setState(p,'window');
      else if (r < 0.97) setState(p,'sleep');
      else setState(p,'sit');
    }

    function setState(p, state){
      if(!p) return;
      const ud = p.userData; dequeueAll(p);
      ud.timer = 0; ud.arrived = false;
      let final = state; let bubbleKey = state;

      if(state === 'wander'){ const dest = randomPointNear(p.position.x, p.position.z, 6); setRoute(p, dest); ud.speed = 0.9 + Math.random()*0.4; }
      else if(state === 'lounge'){ ud.speed = 0; }
      else if(state === 'play'){
        ud.speed = 0.8;
        if (requestResource(p,'play')) { setRoute(p, new THREE.Vector3(RING_X,0,RING_Z)); }
        else { final = 'playWait'; setRoute(p, queueWaitPos('play',p)); bubbleKey = 'play'; }
      }
      else if(state === 'playBlocks'){
        ud.speed = 0.8;
        if (requestResource(p,'playBlocks')) { setRoute(p, BLOCKS_POS.clone()); }
        else { final = 'playBlocksWait'; setRoute(p, queueWaitPos('playBlocks',p)); bubbleKey = 'playBlocks'; }
      }
      else if(state === 'eat'){
        ud.speed = 1.0;
        if (requestResource(p,'eat')) { setRoute(p, dish.position.clone().add(new THREE.Vector3(-0.9,0,0))); }
        else { final = 'eatWait'; setRoute(p, queueWaitPos('eat',p)); bubbleKey = 'eat'; }
      }
      else if(state === 'pond'){
        ud.speed = 1.0;
        if (requestResource(p,'pond')) { setRoute(p, POND_POS.clone()); }
        else { final = 'pondWait'; setRoute(p, queueWaitPos('pond',p)); bubbleKey = 'pond'; }
      }
      else if(state === 'window'){ ud.speed = 1.0; setRoute(p, new THREE.Vector3(7.4,0,0)); }
      else if(state === 'sit'){ ud.speed = 0; }
      else if(state === 'sleep'){
        ud.speed = 1.0;
        if (requestResource(p,'sleep')) { setRoute(p, new THREE.Vector3(BED_SLEEP.x, 0, BED_SLEEP.z)); ud.goingToBed = true; }
        else { final = 'sleepWait'; setRoute(p, queueWaitPos('sleep',p)); bubbleKey = 'sleep'; }
      }
      else if(state === 'wake'){ ud.speed = 0; }

      ud.state = final;
      setBubble(p, bubbleKey);
    }

    const clock = new THREE.Clock();
    function beakWorldPos(p) {
      if (!p) return new THREE.Vector3();
      const forward = new THREE.Vector3(0,0,1).applyQuaternion(p.quaternion);
      return p.position.clone().add(new THREE.Vector3(0,1.0,0)).add(forward.multiplyScalar(0.7));
    }

    function updatePenguin(p, dt) {
      if (!p) return;
      const ud = p.userData;
      if (ud.mixer) ud.mixer.update(dt);
      ud.timer += dt;

      if (ud.state !== 'sit' && ud.state !== 'sleep') { p.position.y = Math.max(0, Math.sin(performance.now()/1000*6)*0.03); }

      if (['wander','play','playBlocks','eat','window','pond','playWait','playBlocksWait','eatWait','pondWait','sleepWait'].includes(ud.state) || (ud.state==='sleep' && ud.goingToBed)) {
        const target = ud.target;
        const v = new THREE.Vector3(target.x - p.position.x, 0, target.z - p.position.z);

        // separation
        const sep = new THREE.Vector3();
        for (const other of penguins) {
          if (other === p) continue;
          const dx = p.position.x - other.position.x;
          const dz = p.position.z - other.position.z;
          const d2 = dx*dx + dz*dz;
          const minD = 1.2;
          if (d2 > 1e-4 && d2 < minD*minD) {
            const d = Math.sqrt(d2);
            const f = (minD - d) / minD;
            sep.x += (dx / d) * f;
            sep.z += (dz / d) * f;
          }
        }
        v.add(sep.multiplyScalar(0.8));

        const dist = Math.hypot(v.x, v.z);
        if (dist > 0.02) {
          v.normalize();
          const speed = ud.speed * dt * 0.9;
          p.position.addScaledVector(v, Math.min(speed, dist));
          const yaw = Math.atan2(v.x, v.z);
          p.rotation.y = yaw + HEADING_OFFSET;
          p.rotation.z = Math.sin(performance.now()/1000*8)*0.05;
        } else {
          if (ud.way && ud.way.length) { ud.target.copy(ud.way.shift()); return; }
          if (ud.state === 'wander') {
            if (ud.timer > 1.0) setState(p,'lounge');
          } else if (ud.state === 'play') {
            if (!ud.arrived) { ud.arrived = true; ud.timer = 0; }
            toys.children.forEach(t => { if (t.geometry && t.geometry.type === 'TorusGeometry') t.position.y = 0.35 + Math.sin(performance.now()/1000*6)*0.07; });
            if (ud.timer > (1.0 + Math.random()*1.0)) { releaseResource('play'); chooseNextAction(p); }
          } else if (ud.state === 'playBlocks') {
            if (!ud.arrived) { ud.arrived = true; ud.timer = 0; }
            const wobble = Math.sin(performance.now()/1000 * 6) * 0.12; blocks.forEach(b => { b.rotation.y = wobble; });
            if (ud.timer > (1.0 + Math.random()*1.0)) { blocks.forEach(b=>b.rotation.y=0); releaseResource('playBlocks'); chooseNextAction(p); }
          } else if (ud.state === 'eat') {
            if (!ud.fish) {
              ud.fish = makeFish();
              ud.fish.position.copy(dish.position).add(new THREE.Vector3(Math.random()*0.3, 0.2, Math.random()*0.3));
              scene.add(ud.fish);
            } else {
              const beakPos = beakWorldPos(p);
              ud.fish.position.lerp(beakPos, Math.min(1, dt*1.5));
              if (ud.fish.position.distanceTo(beakPos) < 0.06) {
                scene.remove(ud.fish); ud.fish = null; releaseResource('eat'); chooseNextAction(p);
              }
            }
          } else if (ud.state === 'sleep' && ud.goingToBed) {
            p.position.y = BED_SLEEP.y;
            p.rotation.y = Math.PI/2 + HEADING_OFFSET;
            ud.goingToBed = false; ud.timer = 0;
          } else if (ud.state === 'window') {
            p.rotation.y = Math.PI/2 + HEADING_OFFSET;
            if (!ud.arrived) { ud.arrived = true; ud.timer = 0; }
            if (ud.timer > (1.0 + Math.random()*1.0)) chooseNextAction(p);
          } else if (ud.state === 'pond') {
            if (!ud.arrived) { ud.arrived = true; ud.timer = 0; spawnSplash(p.position.clone().setY(0.08), 8); }
            p.position.y = Math.sin(performance.now()/1000 * 8) * 0.03;
            if (ud.timer > (1.4 + Math.random()*0.8)) { p.position.y = 0; releaseResource('pond'); chooseNextAction(p); }
          }
        }
      } else if (ud.state === 'lounge') {
        p.rotation.z = 0; if (ud.timer > (2 + Math.random()*3)) chooseNextAction(p);
      } else if (ud.state === 'sit') {
        p.rotation.z = 0; if (ud.timer > (2 + Math.random()*3)) chooseNextAction(p);
      } else if (ud.state === 'sleep') {
        p.rotation.set(0, p.rotation.y, 0);
        p.rotation.x = Math.PI/2 * 0.8;
        if (ud.timer > (3 + Math.random()*3)) setState(p,'wake');
      } else if (ud.state === 'wake') {
        p.rotation.x = THREE.MathUtils.damp(p.rotation.x, 0, 6, dt);
        if (Math.abs(p.rotation.x) < 0.02) { p.rotation.x = 0; releaseResource('sleep'); chooseNextAction(p); }
      }

      p.position.x = THREE.MathUtils.clamp(p.position.x, bounds.xMin, bounds.xMax);
      p.position.z = THREE.MathUtils.clamp(p.position.z, bounds.zMin, bounds.zMax);
    }

    // ---- Boy.glb ----
    const mixers = []; // Boyのアニメーション更新用
    function fitAndFloorToHeight(obj, targetH){
      const tmp = new THREE.Group(); tmp.add(obj); scene.add(tmp);
      tmp.updateWorldMatrix(true,true);
      const box = new THREE.Box3().setFromObject(tmp);
      const size = new THREE.Vector3(); box.getSize(size);
      const s = (size.y > 0 ? targetH / size.y : 1);
      obj.scale.setScalar(s);
      tmp.updateWorldMatrix(true,true);
      const box2 = new THREE.Box3().setFromObject(tmp);
      obj.position.y += -box2.min.y;
      scene.remove(tmp);
      return obj;
    }

    function spawnBoy(url, pos){
      gltfLoader.load(url, (gltf)=>{
        const boy = new THREE.Group();
        const model = gltf.scene;
        fitAndFloorToHeight(model, 1.55 * 0.01); // 1/100 サイズ // 身長調整
        boy.add(model);
        boy.position.copy(pos);
      // 池の方向 +135° を向かせる
      const yaw = Math.atan2(POND_POS.x - boy.position.x, POND_POS.z - boy.position.z) + (135 * Math.PI / 180);
      boy.rotation.y = yaw;
      scene.add(boy);

        // アニメーションを無限ループで自動再生
        if (gltf.animations && gltf.animations.length){
          const mixer = new THREE.AnimationMixer(model);
          const idle = gltf.animations.find(a => /idle/i.test(a.name)) || gltf.animations[0];
          const action = mixer.clipAction(idle);
          action.setLoop(THREE.LoopRepeat, Infinity).play();
          mixers.push(mixer);
        }
      }, undefined, (err)=>console.warn('Boy.glb load error', err));
    }

    // 池の右下あたりに Boy を配置
    const boyPos = new THREE.Vector3(0, 0, 0);
    spawnBoy('Boy.glb', boyPos);

    // ---- Loop ----
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // penguins
      for (const p of penguins) updatePenguin(p, dt);

      // boy mixers
      for (const m of mixers) m.update(dt);

      const t = performance.now()/1000;
      mf1.rotation.y = Math.sin(t*1.6)*0.4; mf2.rotation.y = Math.cos(t*1.4)*0.4; mf3.rotation.y = Math.sin(t*1.8+0.7)*0.4;
      penguin = penguins[0] || null;
      for (const p of penguins) updateBubblePositionFor(p);
      if (garden.userData && garden.userData.catHead) {
        garden.userData.catHead.rotation.y = Math.sin(t*0.7)*0.3;
        garden.userData.catTail.rotation.z = Math.sin(t*2.4)*0.35;
      }
      // droplets
      for (let i=droplets.length-1; i>=0; i--) {
        const d = droplets[i];
        d.userData.vel.y -= 3.5 * dt;
        d.position.addScaledVector(d.userData.vel, dt);
        d.userData.life -= dt;
        d.material.opacity = Math.max(0, d.userData.life / 0.7);
        if (d.userData.life <= 0 || d.position.y <= 0.02) { scene.remove(d); droplets.splice(i,1); }
      }
      renderer.render(scene, camera);
    }
    animate();

    // ---- Interactions ----
    function handleAdvance(e){ const el = e.target; if (el && el.closest && (el.closest('.picker') || el.closest('.drop'))) return; for (const p of penguins) chooseNextAction(p); }
    window.addEventListener('click', handleAdvance);
    window.addEventListener('touchend', handleAdvance, { passive: true });
    window.addEventListener('pointerup', handleAdvance);

    // ---- Drag & drop ----
    const drop = $('drop');
    addEventListener('dragover', (e) => { e.preventDefault(); drop.classList.add('on'); });
    addEventListener('dragleave', (e) => { e.preventDefault(); drop.classList.remove('on'); });
    addEventListener('drop', (e) => {
      e.preventDefault(); drop.classList.remove('on');
      const f = e.dataTransfer.files?.[0]; if (!f) return;
      setStatus('reading ' + f.name + ' ...');
      f.arrayBuffer().then((ab) => {
        gltfLoader.parse(ab, '', (gltf) => {
          setStatus('parsed.');
          const g = new THREE.Group();
          const model = fitAndFloor(gltf.scene);
          g.add(model);
          g.userData = { speed:0, state:'idle', target:new THREE.Vector3(), timer:0, model };
          scene.add(g);
          if (!penguin) penguin = g; penguins.push(g);
          setState(g,'wander');
        }, (err) => setStatus('parse error: ' + (err?.message || err)) );
      });
    });

    // ---- Auto spawn penguins ----
    const params = new URLSearchParams(location.search);
    const modelUrl = params.get('model') || 'Pen.glb';
    function spawn(url, start){
      loadPenguin(url).then((g)=>{ if (start) g.position.copy(start); scene.add(g); penguins.push(g); if (!penguin) penguin = g; setState(g,'wander'); })
      .catch(()=>{ const fb=fallbackPenguin(); if (start) fb.position.copy(start); scene.add(fb); penguins.push(fb); if (!penguin) penguin = fb; setState(fb,'wander'); });
    }
    spawn(modelUrl, new THREE.Vector3(-1,0,0));
    ['Pen_b.glb','Pen_r.glb','Pen_y.glb','Pen_g.glb'].forEach((u,i)=>{ const starts=[ new THREE.Vector3(1.0,0,-1.2), new THREE.Vector3(-2.5,0,1.2), new THREE.Vector3(0,0,2.0), new THREE.Vector3(2.5,0,2.0) ]; spawn(u, starts[i]); });

    // ---- Console helpers ----
    window.__penguin = { scene, camera, setState, chooseNextAction, get penguin(){ return penguin; }, get penguins(){ return penguins; } };
    setStatus('initialized OK');
  </script>

  <!-- Eruda: mobile devtools -->
  <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
  <script>try{ eruda.init({ defaults: { displaySize: 50 }, tool: [ 'console','network','resources' ] }); console.log('Eruda ready'); }catch(e){ console.warn('Eruda init failed', e); }</script>
</body>
</html>
